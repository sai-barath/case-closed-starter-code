package main

import (
	"encoding/csv"
	"fmt"
	"os"
	"strconv"
)

// Simple linear regression: final_space_diff = K1 * node_diff + K2 * edge_diff
// We solve for K1 and K2 using least squares

type DataPoint struct {
	nodeDiff       float64
	edgeDiff       float64
	finalSpaceDiff float64
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run learn_weights.go <training_data.csv>")
		os.Exit(1)
	}

	filename := os.Args[1]
	data, err := loadData(filename)
	if err != nil {
		fmt.Printf("Error loading data: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Loaded %d data points\n", len(data))

	if len(data) == 0 {
		fmt.Println("No data to train on")
		os.Exit(1)
	}

	k1, k2 := fitLinearRegression(data)

	fmt.Printf("\nOptimal coefficients:\n")
	fmt.Printf("K1 (node weight) = %.6f\n", k1)
	fmt.Printf("K2 (edge weight) = %.6f\n", k2)
	fmt.Printf("\nScaled for integers (*1000):\n")
	fmt.Printf("Territory multiplier: %d\n", int(k1*1000))
	fmt.Printf("Edge multiplier: %d\n", int(k2*1000))

	// Calculate R^2 to show goodness of fit
	r2 := calculateR2(data, k1, k2)
	fmt.Printf("\nRÂ² = %.4f (1.0 is perfect fit)\n", r2)

	// Show current weights for comparison
	fmt.Printf("\nCurrent weights in code:\n")
	fmt.Printf("Territory: 200x\n")
	fmt.Printf("Edge: 30x\n")
}

func loadData(filename string) ([]DataPoint, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}

	if len(records) < 2 {
		return nil, fmt.Errorf("no data in CSV")
	}

	data := make([]DataPoint, 0, len(records)-1)

	// Skip header row
	for i := 1; i < len(records); i++ {
		if len(records[i]) < 3 {
			continue
		}

		nodeDiff, err1 := strconv.ParseFloat(records[i][0], 64)
		edgeDiff, err2 := strconv.ParseFloat(records[i][1], 64)
		spaceDiff, err3 := strconv.ParseFloat(records[i][2], 64)

		if err1 == nil && err2 == nil && err3 == nil {
			data = append(data, DataPoint{
				nodeDiff:       nodeDiff,
				edgeDiff:       edgeDiff,
				finalSpaceDiff: spaceDiff,
			})
		}
	}

	return data, nil
}

func fitLinearRegression(data []DataPoint) (float64, float64) {
	// Build normal equations for least squares
	// We want to minimize: sum((y - (k1*x1 + k2*x2))^2)
	// Where: y = finalSpaceDiff, x1 = nodeDiff, x2 = edgeDiff

	var sumX1 float64   // sum of node_diff
	var sumX2 float64   // sum of edge_diff
	var sumY float64    // sum of final_space_diff
	var sumX1X1 float64 // sum of node_diff^2
	var sumX2X2 float64 // sum of edge_diff^2
	var sumX1X2 float64 // sum of node_diff * edge_diff
	var sumX1Y float64  // sum of node_diff * final_space_diff
	var sumX2Y float64  // sum of edge_diff * final_space_diff

	for _, dp := range data {
		sumX1 += dp.nodeDiff
		sumX2 += dp.edgeDiff
		sumY += dp.finalSpaceDiff
		sumX1X1 += dp.nodeDiff * dp.nodeDiff
		sumX2X2 += dp.edgeDiff * dp.edgeDiff
		sumX1X2 += dp.nodeDiff * dp.edgeDiff
		sumX1Y += dp.nodeDiff * dp.finalSpaceDiff
		sumX2Y += dp.edgeDiff * dp.finalSpaceDiff
	}

	// Solve 2x2 system of normal equations:
	// [sumX1X1  sumX1X2] [k1]   [sumX1Y]
	// [sumX1X2  sumX2X2] [k2] = [sumX2Y]

	det := sumX1X1*sumX2X2 - sumX1X2*sumX1X2

	if det == 0 {
		fmt.Println("Warning: singular matrix, using fallback values")
		return 0.055, 0.194
	}

	k1 := (sumX2X2*sumX1Y - sumX1X2*sumX2Y) / det
	k2 := (sumX1X1*sumX2Y - sumX1X2*sumX1Y) / det

	return k1, k2
}

func calculateR2(data []DataPoint, k1, k2 float64) float64 {
	var ssRes float64 // sum of squared residuals
	var ssTot float64 // total sum of squares

	// Calculate mean of y values
	var meanY float64
	for _, dp := range data {
		meanY += dp.finalSpaceDiff
	}
	meanY /= float64(len(data))

	// Calculate SS
	for _, dp := range data {
		predicted := k1*dp.nodeDiff + k2*dp.edgeDiff
		residual := dp.finalSpaceDiff - predicted
		ssRes += residual * residual

		deviation := dp.finalSpaceDiff - meanY
		ssTot += deviation * deviation
	}

	if ssTot == 0 {
		return 0
	}

	return 1 - (ssRes / ssTot)
}
